# 郑晨升编译课设第二次阶段报告
## 后端—目标代码生成
  目标代码生成是编译程序的最后一个阶段，它以中间代码作为输入，以与中间代码功能相同的目标代码作为输出。在进行代码生成时，不仅要考虑如何使生成的代码尽量短，还要考虑如何更多地利用寄存器，使目标代码执行的时间更短。
  本次课设采用的中间代码为四元式，采用单寄存器的方法，生成的目标代码为基于8086的汇编语言代码。
  由于本次课设采用递进的方法进行：首先完成的是在基础的算术表达式基础上加入if,while，在这一步完成了从词法分析到目标代码生成的全过程；

## 目前的进度
  本人负责本次编译原理课程设计的后端部分，目前为止完成了最基本语法的目标代码生成（8086汇编语言）的功能实现，即声明语句、定义语句、算术表达式、赋值语句、逻辑表达式、if语句、while语句。

### 相关数据结构
1. 四元式
```c++
vector：vector<SIY> FourStyle;
typedef struct
{
	       string deli;  //表示四元式中的算符
	       string first;  //表示第一个运算数据
	       string second; //表示第二个运算数据
	       string third;  //表示运算结果符号
	       int f;         //表示第一个运算数据的活跃信息
	       int s;         //表示第二个运算数据的活跃信息
	       int t;         //表示第三个运算数据的活跃信息
}SIY;
```
2. 简易符号表
```c++
vector: vector<SymbolNode> Symbol;
typedef struct 
{
	       string data;
	       int type;  //0-float临时变量；1-float非临时变量；
//2-string临时变量；3-string非临时变量
	       int state; //1-y；0-n；
}SymbolNode;
```
3. 基本块划分形成的块
```c++
vector：vector<block_begin_end> block;
struct block_begin_end
{
	       int begin;  //标记一个基本块的四元式开始序号
	       int end;    //标记一个基本块的四元式最后序号
};
```
4. 寄存器中信息的结构体
```c++
typedef struct 
{
	       string data;  //寄存器中的数据     
	       int state;   //该数据的活跃信息；y-1;n-0;    
}RDL;
```
5. 数据段数据及类型
```c++
vector<StorageUnit> iden;
struct StorageUnit
{
	       string data;//需要存储的单元
	       int type;    //普通数据-1；字符串-2
};
```
6. 简易符号表的各个函数块内局部变量的个数
```c++
vector：vector<int> number;
```
7. 存放目标代码
```c++
vector：vector<string> OBJ;
```
8. 用来记录各个循环中的各个跳出跳入标识符
```c++
stack：stack<string> SEM;
```

### 算法流程
  首先对四元式进行基本块的划分；对每个基本块初始化变量的活跃信息，然后逆序对每个四元式内涉及的变量的活跃信息更新，再在每个基本块内按照符号表中对应的局部变量进行对于目标代码数据段的编写，这是第一次扫描。再一次对于每个基本块初始化变量的活跃信息，然后逆序队每个四元式内涉及的变量的活跃信息更新，再依次取出四元式进行目标代码编写，同时更新当前寄存器的信息，当一个基本块结束时，释放寄存器的内容。最后再编写目标代码的结尾。
## 之后的工作
  首先要进行的工作为与负责前端的其他同学的结果进行对接，即将前端同学得到的中间代码（四元式）和符号表与本人设计实现的目标代码生成进行对接。在有余力的情况下，首先要提高目标代码的正确性，通过汇编语言的编译和运行；其次，完成中间代码的优化；最后要增加目标代码生成的功能，比如函数、结构体、数组等的实现。